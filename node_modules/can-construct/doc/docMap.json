{"Construct":{"name":"Construct","type":"add","description":"undefined\n"},"Construct.static":{"src":{"line":60,"codeLine":63,"path":"can-construct.js"},"type":"static","body":"","description":"\n","name":"Construct.static","parent":"Construct"},"Construct.constructorExtends":{"name":"Construct.constructorExtends","type":"property","parent":"Construct.static","src":{"line":64,"codeLine":131,"path":"can-construct.js"},"body":"\n If `constructorExtends` is:\n\n  - `true` - the constructor extends\n  - `false` - a new instance of the constructor is created\n\n This property defaults to false.\n\n Example of constructExtends is true:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: true // the constructor extends\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var Pony = Animal({\n   gallop: function () {\n      console.log(\"Galloping!!\");\n   }\n }); // Pony is now a constructor function extended from Animal\n\n var frank = new Animal(); // frank is a new instance of Animal\n\n var gertrude = new Pony(); // gertrude is a new instance of Pony\n gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n```\n\n The default behavior is shown in the example below:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: false // the constructor does NOT extend\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var pony = Animal(); // pony is a new instance of Animal\n var frank = new Animal(); // frank is a new instance of Animal\n\n pony.sayHi() // \"hai!\"\n frank.sayHi() // \"hai!\"\n```\n By default to extend a constructor, you must use [Construct.extend extend].\n\t \n","description":"  Toggles the behavior of a constructor function called\n without the `new` keyword to extend the constructor function or\n create a new instance.\n\n ```js\n var animal = Animal();\n // vs\n var animal = new Animal();\n ```\n\n","types":[{"type":"Boolean"}],"title":"Construct.constructorExtends","comment":" "},"Construct.newInstance":{"type":"function","name":"Construct.newInstance","parent":"Construct.static","src":{"line":132,"codeLine":197,"path":"can-construct.js"},"body":"Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n__new__ operator.\n\n## Example\n\nThe following creates a `Person` Construct and overrides `newInstance` to cache all\ninstances of Person to prevent duplication. If the properties of a new Person match an existing one it\nwill return a reference to the previously created object, otherwise it returns a new object entirely.\n\n```js\n// define and create the Person constructor\nvar Person = Construct.extend({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\n// store a reference to the original newInstance function\nvar _newInstance = Person.newInstance;\n\n// override Person's newInstance function\nPerson.newInstance = function() {\n// if cache does not exist make it an new object\nthis.__cache = this.__cache || {};\n// id is a stingified version of the passed arguments\nvar id = JSON.stringify(arguments);\n\n// look in the cache to see if the object already exists\nvar cachedInst = this.__cache[id];\nif(cachedInst) {\n    return cachedInst;\n}\n\n//otherwise call the original newInstance function and return a new instance of Person.\nvar newInst = _newInstance.apply(this, arguments);\nthis.__cache[id] = newInst;\nreturn newInst;\n}\n\n// create two instances with the same arguments\nvar justin = new Person('Justin', 'Barry', 'Meyer'),\n\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\nconsole.log(justin === brian); // true - both are references to the same instance\n```\n\n \n","description":"Returns an instance of `Construct`. This method can be overridden to return a cached instance.\n\n","title":"newInstance","signatures":[{"code":"Construct.newInstance([...args])","description":"\n","params":[{"types":[{"type":"*"}],"optional":true,"name":"args","description":"arguments that get passed to [Construct::setup] and [Construct::init]. Note\nthat if [Construct::setup] returns an array, those arguments will be passed to [Construct::init]\ninstead."}],"returns":{"types":[{"type":"class"}],"description":"instance of the class\n"}}],"_curParam":{"types":[{"type":"*"}],"optional":true,"name":"args","description":"arguments that get passed to [Construct::setup] and [Construct::init]. Note\nthat if [Construct::setup] returns an array, those arguments will be passed to [Construct::init]\ninstead."},"_curReturn":{"types":[{"type":"class"}],"description":"instance of the class\n"},"comment":" "},"Construct.setup":{"type":"function","name":"Construct.setup","parent":"Construct.static","src":{"line":240,"codeLine":301,"path":"can-construct.js"},"body":"The static `setup` method is called immediately after a constructor\nfunction is created and\nset to inherit from its base constructor. It is useful for setting up\nadditional inheritance work.\nDo not confuse this with the prototype `[Construct::setup]` method.\n\n## Example\n\nThis `Parent` class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.\n\n```js\nParent = Construct.extend({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // Construct\n\nChild = Parent({});\n\nChild.base; // Parent\n```\n \n","description":"Perform initialization logic for a constructor function. \n","title":"setup","signatures":[{"code":"Construct.setup(base, fullName, staticProps, protoProps)","description":"\n\nA static `setup` method provides inheritable setup functionality\nfor a Constructor function. The following example\ncreates a Group constructor function.  Any constructor\nfunctions that inherit from Group will be added to\n`Group.childGroups`.\n\n\n    Group = Construct.extend({\n      setup: function(Construct, fullName, staticProps, protoProps){\n        this.childGroups = [];\n        if(Construct !== Construct){\n          this.childGroups.push(Construct)\n        }\n        Construct.setup.apply(this, arguments)\n      }\n    },{})\n    var Flock = Group.extend(...)\n    Group.childGroups[0] //-> Flock\n","params":[{"types":[{"type":"constructor"}],"name":"base","description":"The base constructor that is being inherited from."},{"types":[{"type":"String"}],"name":"fullName","description":"The name of the new constructor."},{"types":[{"type":"Object","options":[]}],"name":"staticProps","description":"The static properties of the new constructor."},{"types":[{"type":"Object","options":[]}],"name":"protoProps","description":"The prototype properties of the new constructor.\n"}]}],"_curParam":{"types":[{"type":"Object","options":[]}],"name":"protoProps","description":"The prototype properties of the new constructor.\n"},"comment":" "},"Construct.extend":{"type":"function","name":"Construct.extend","parent":"Construct.static","src":{"line":315,"codeLine":456,"path":"can-construct.js"},"body":"## Inheritance\nCreating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our `Snake` to\nbe an `Animal`, but there are some differences:\n\n\n    var Snake = Animal.extend({\n        legs: 0\n    }, {\n        init: function() {\n            Animal.prototype.init.call(this, 'ssssss');\n        },\n        slither: function() {\n            console.log('slithering...');\n        }\n    });\n\n    var baslisk = new Snake();\n    baslisk.speak();   // \"ssssss\"\n    baslisk.slither(); // \"slithering...\"\n    baslisk instanceof Snake;  // true\n    baslisk instanceof Animal; // true\n\n\n## Static properties and inheritance\n\nIf you pass all three arguments to Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the `[Construct::constructor this.constructor]` property.\n\nStatic properties can get overridden through inheritance just like instance properties. In the example below,\nwe override both the legs static property as well as the the init function for each instance:\n\n```js\nvar Animal = Construct.extend({\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    },\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nvar Snake = Animal.extend({\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0\nvar dog = new Animal('woof');\nvar blackMamba = new Snake();\ndog.speak(); // 'woof'\nblackMamba.speak(); // 'ssssss'\n```\n \n","description":"\n","title":"extend","signatures":[{"code":"Construct.extend([name,] [staticProperties,] instanceProperties)","description":"\n\nExtends `Construct`, or constructor functions derived from `Construct`,\nto create a new constructor function. Example:\n\n```js\nvar Animal = Construct.extend({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n});\n\nvar animal = new Animal()\nanimal.sayHi();\n```\n","params":[{"types":[{"type":"String"}],"optional":true,"name":"name","description":"Creates the necessary properties and\nobjects that point from the `window` to the created constructor function. The following:\n\n    Construct.extend(\"company.project.Constructor\",{})\n\ncreates a `company` object on window if it does not find one, a\n`project` object on `company` if it does not find one, and it will set the\n`Constructor` property on the `project` object to point to the constructor function.\n\nFinally, it sets \"company.project.Constructor\" as [Construct.fullName fullName]\nand \"Constructor\" as [Construct.shortName shortName].\n"},{"types":[{"type":"Object","options":[]}],"optional":true,"name":"staticProperties","description":"Properties that are added the constructor\nfunction directly. For example:\n\n```js\nvar Animal = Construct.extend({\n  findAll: function(){\n    return can.ajax({url: \"/animals\"})\n  }\n},{}); // need to pass an empty instanceProperties object\n\nAnimal.findAll().then(function(json){ ... })\n```\n\nThe [Construct.setup static setup] method can be used to\nspecify inheritable behavior when a Constructor function is created.\n"},{"types":[{"type":"Object","options":[]}],"name":"instanceProperties","description":"Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [Construct::init init] and [Construct::setup setup] properties\nare used for initialization.\n"}],"returns":{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"description":"The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"}}],"_curParam":{"types":[{"type":"Object","options":[]}],"name":"instanceProperties","description":"Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [Construct::init init] and [Construct::setup setup] properties\nare used for initialization.\n"},"_curReturn":{"types":[{"type":"function","returns":{"types":[{"type":"undefined"}]},"params":[]}],"description":"The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"},"comment":" "},"Construct.namespace":{"name":"Construct.namespace","type":"property","parent":"Construct.static","src":{"line":545,"codeLine":560,"path":"can-construct.js"},"body":"\n```js\nConstruct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"\n```\n\t\t \n","description":"\nThe `namespace` property returns the namespace your constructor is in.\nThis provides a way organize code and ensure globally unique types. The\n`namespace` is the [Construct.fullName fullName] you passed without the [Construct.shortName shortName].\n","types":[{"type":"String"}],"title":"namespace"},"Construct.shortName":{"src":{"line":561,"codeLine":577,"path":"can-construct.js"},"type":"property","body":"\n```js\nConstruct(\"MyApplication.MyConstructor\",{},{});\nMyApplication.MyConstructor.namespace // \"MyApplication\"\nMyApplication.MyConstructor.shortName // \"MyConstructor\"\nMyApplication.MyConstructor.fullName  // \"MyApplication.MyConstructor\"\n```\n\t\t \n","description":"\nIf you pass a name when creating a Construct, the `shortName` property will be set to the\nname you passed without the [Construct.namespace namespace].\n","types":[{"type":"String"}],"title":"shortName","name":"Construct.shortName","parent":"Construct.static"},"Construct.prototype":{"src":{"line":588,"codeLine":591,"path":"can-construct.js"},"type":"prototype","body":"","description":"\t \n","name":"Construct.prototype","parent":"Construct"},"Construct.prototype.constructor":{"src":{"line":592,"codeLine":621,"path":"can-construct.js"},"type":"property","body":"\n## Example\n\nThis Construct has a static counter that counts how many instances have been created:\n\n```js\nvar Counter = Construct.extend({\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nvar childCounter = new Counter();\nconsole.log(childCounter.constructor.count); // 1\nconsole.log(Counter.count); // 1\n```\n\t \n","description":"\nA reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.\n","types":[{"type":"Object","options":[]}],"title":"constructor","name":"Construct.prototype.constructor","parent":"Construct.prototype","comment":" "},"Construct.prototype.setup":{"type":"function","name":"Construct.prototype.setup","parent":"Construct.prototype","src":{"line":621,"codeLine":687,"path":"can-construct.js"},"body":"\n## Deciding between `setup` and `init`\n\n\nUsually, you should use [Construct::init init] to do your constructor function's initialization.\nYou should, instead, use `setup` when:\n\n  - there is initialization code that you want to run before the inheriting constructor's\n    `init` method is called.\n  - there is initialization code that should run whether or not inheriting constructors\n    call their base's `init` methods.\n  - you want to modify the arguments that will get passed to `init`.\n\n## Example\n\nThis code is a simplified version of the code in [can.Control]'s setup\nmethod. It converts the first argument to a jQuery collection and\nextends the controller's defaults with the options that were passed.\n\n\n    can.Control = Construct.extend({\n        setup: function(domElement, rawOptions) {\n            // set up this.element\n            this.element = $(domElement);\n\n            // set up this.options\n            this.options = can.extend({},\n                                  this.constructor.defaults,\n                                  rawOptions\n                                 );\n\n            // pass this.element and this.options to init.\n            return [this.element, this.options];\n        }\n    });\n\n\n","description":"\n","title":"setup","signatures":[{"code":"construct.setup(...args)","description":"\n\nA setup function for the instantiation of a constructor function.\n","params":[{"types":[{"type":"*"}],"name":"args","description":"The arguments passed to the constructor.\n"}],"returns":{"types":[{"type":"Array"},{"type":"undefined"}],"description":"If an array is returned, the array's items are passed as\narguments to [Construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n    WidgetFactory = Construct.extend({\n        setup: function(element){\n            return [$(element)]\n        }\n    })\n\n    MyWidget = WidgetFactory.extend({\n        init: function($el){\n            $el.html(\"My Widget!!\")\n        }\n    })\n\nOtherwise, the arguments to the\nconstructor are passed to [Construct::init] and the return value of `setup` is discarded.\n"}}],"_curParam":{"types":[{"type":"*"}],"name":"args","description":"The arguments passed to the constructor.\n"},"_curReturn":{"types":[{"type":"Array"},{"type":"undefined"}],"description":"If an array is returned, the array's items are passed as\narguments to [Construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n    WidgetFactory = Construct.extend({\n        setup: function(element){\n            return [$(element)]\n        }\n    })\n\n    MyWidget = WidgetFactory.extend({\n        init: function($el){\n            $el.html(\"My Widget!!\")\n        }\n    })\n\nOtherwise, the arguments to the\nconstructor are passed to [Construct::init] and the return value of `setup` is discarded.\n"},"comment":" "},"Construct.prototype.init":{"type":"function","name":"Construct.prototype.init","parent":"Construct.prototype","src":{"line":688,"codeLine":747,"path":"can-construct.js"},"body":"If a prototype `init` method is provided, `init` is called when a new Construct is created---\nafter [Construct::setup]. The `init` method is where the bulk of your initialization code\nshould go. A common thing to do in `init` is save the arguments passed into the constructor.\n\n## Examples\n\nFirst, we'll make a Person constructor that has a first and last name:\n\n```js\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"\n```\n\nThen, we'll extend Person into Programmer, and add a favorite language:\n\n```js\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n```\n\n## Modified Arguments\n\n[Construct::setup] is able to modify the arguments passed to `init`.\nIf you aren't receiving the arguments you passed to `new Construct(args)`,\ncheck that they aren't being changed by `setup` along\nthe inheritance chain.\n\n","description":"Called when a new instance of a Construct is created. \n","title":"init","signatures":[{"code":"construct.init(...args)","description":"","params":[{"types":[{"type":"*"}],"name":"args","description":"the arguments passed to the constructor (or the items of the array returned from [Construct::setup])\n"}]}],"_curParam":{"types":[{"type":"*"}],"name":"args","description":"the arguments passed to the constructor (or the items of the array returned from [Construct::setup])\n"},"comment":" "},"can-construct":{"src":{"path":"can-construct.md"},"body":"\neasy constructor functions\n\n","description":"\n# can-construct\n","name":"can-construct","type":"page"}}