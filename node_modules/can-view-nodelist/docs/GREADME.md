
- <code>[__can-view-nodelist__ Object](#can-view-nodelist-object)</code>
  - <code>[nodeLists.id(node, localMap)](#nodelistsidnode-localmap)</code>
  - <code>[nodeLists.update(nodeList, newNodes)](#nodelistsupdatenodelist-newnodes)</code>
  - <code>[nodeLists.nestReplacement(list)](#nodelistsnestreplacementlist)</code>
  - <code>[nodeLists.nestList(list)](#nodelistsnestlistlist)</code>
  - <code>[nodeLists.last(nodeList)](#nodelistslastnodelist)</code>
  - <code>[nodeLists.first(nodeList)](#nodelistsfirstnodelist)</code>
  - <code>[nodeLists.register(nodeList, unregistered, parent, directlyNested)](#nodelistsregisternodelist-unregistered-parent-directlynested)</code>
  - <code>[nodeLists.unregisterChildren(nodeList)](#nodelistsunregisterchildrennodelist)</code>
  - <code>[nodeLists.unregister(nodeList, isChild)](#nodelistsunregisternodelist-ischild)</code>
  - <code>[nodeLists.after(oldElements, newFrag)](#nodelistsafteroldelements-newfrag)</code>
  - <code>[nodeLists.remove(elementsToBeRemoved)](#nodelistsremoveelementstoberemoved)</code>
  - <code>[nodeLists.replace(oldElements, newFrag)](#nodelistsreplaceoldelements-newfrag)</code>

## API

##  `{Object}`

Adds nesting of text nodes 
`can.view.nodeLists` are used to make sure "directly nested" live-binding
sections update content correctly.

Consider the following template:

```html
<div>
{{#if items.length}}
    Items:
        {{#items}}
            <label></label>
        {{/items}}
{{/if}}
</div>
```

The `{{#if}}` and `{{#items}}` seconds are "directly nested" because
they share the same `<div>` parent element.

If `{{#items}}` changes the DOM by adding more `<labels>`,
`{{#if}}` needs to know about the `<labels>` to remove them
if `{{#if}}` is re-rendered.  `{{#if}}` would be re-rendered, for example, if
all items were removed.




### <code>Object</code>


### <code>nodeLists.id(node, localMap)</code>


1. __node__ <code>{Object}</code>:
  an HTML element, text node, or other object
1. __localMap__ <code>{Object}</code>:
  an optional map for text node IDs

- __returns__ <code>{String}</code>:
  the ID value generated for the node.
  
  Given a template node, create an id on the node as a expando
  property, or if the node is an HTMLTextNode and the browser
  doesn't support expando properties store the id with a
  reference to the text node in an internal collection then return
  the lookup id.
  
  

### <code>nodeLists.update(nodeList, newNodes)</code>



1. __nodeList__ <code>{ArrayLike}</code>:
  the list to update with the new nodes
1. __newNodes__ <code>{ArrayLike}</code>:
  the new nodes to update with
    

- __returns__ <code>{Array}</code>:
  the nodes that were removed from `nodeList`
  
     Updates a nodeList with new items, i.e. when values for the template have changed.
  

### <code>nodeLists.nestReplacement(list)</code>


1. __list__ <code>{ArrayLike}</code>:
  The nodeList of nodes to go over

- __returns__ <code>{void}</code>:
  
  
   Goes through each node in the list. [el1, el2, el3, ...]
  Finds the nodeList for that node in replacements.  el1's nodeList might look like [el1, [el2]].
  Replaces that element and any other elements in the node list with the
  nodelist itself. resulting in [ [el1, [el2]], el3, ...]
  If a replacement is not found, it was improperly added, so we add it as a deepChild.
  

### <code>nodeLists.nestList(list)</code>


1. __list__ <code>{ArrayLike}</code>:
  the nodeList being nested

- __returns__ <code>{void}</code>:
  
  
  If a given list does not exist in the nodeMap then create an lookup
  id for it in the nodeMap and assign the list to it.
  If the the provided does happen to exist in the nodeMap update the
  elements in the list.
  

### <code>nodeLists.last(nodeList)</code>


1. __nodeList__ <code>{ArrayLike}</code>:
  a nodeList

- __returns__ <code>{HTMLElement}</code>:
  the last element of the last list nested in this list.
  
  Return the last HTMLElement in a nodeList; if the last
  element is a nodeList, returns the last HTMLElement of
  the child list, etc.
  

### <code>nodeLists.first(nodeList)</code>


1. __nodeList__ <code>{ArrayLike}</code>:
  a nodeList

- __returns__ <code>{HTMLElement}</code>:
  the first element of the first list nested in this list.
  
  Return the first HTMLElement in a nodeList; if the first
  element is a nodeList, returns the first HTMLElement of
  the child list, etc.
  

### <code>nodeLists.register(nodeList, unregistered, parent, directlyNested)</code>


1. __nodeList__ <code>{ArrayLike}</code>:
  a nodeList
1. __unregistered__ <code>{function}</code>:
  a callback to call when the nodeList is unregistered
1. __parent__ <code>{ArrayLike}</code>:
  the parent nodeList of this nodeList
1. __directlyNested__ <code>{Boolean}</code>:
  true if nodes in the nodeList are direct children of the parent

- __returns__ <code>{ArrayLike}</code>:
  the passed in nodeList
  
  Registers a nodeList and returns the nodeList passed to register
  

### <code>nodeLists.unregisterChildren(nodeList)</code>


1. __nodeList__ <code>{ArrayLike}</code>:
  The nodeList of child nodes to unregister.

- __returns__ <code>{Array}</code>:
  the list of all nodes that were unregistered
  
  Unregister all childen within the provided list and return the
  unregistred nodes.
  

### <code>nodeLists.unregister(nodeList, isChild)</code>


1. __nodeList__ <code>{ArrayLike}</code>:
  a nodeList to unregister from its parent
1. __true__ <code>{isChild}</code>:
  if the nodeList is a direct child, false if a deep child

- __returns__ <code>{Array}</code>:
  a list of all nodes that were unregistered
  
  Unregister's a nodeList and returns the unregistered nodes.
  Call if the nodeList is no longer being updated. This will
  also unregister all child nodeLists.
  

### <code>nodeLists.after(oldElements, newFrag)</code>


1. __oldElements__ <code>{ArrayLike}</code>:
  the nodeList to use as reference
1. __newFrag__ <code>{DocumentFragment}</code>:
  the fragment to insert

- __returns__ <code>{void}</code>:
  
  
  Inserts `newFrag` after `oldElements`.
  
   

### <code>nodeLists.remove(elementsToBeRemoved)</code>


1. __oldElements__ <code>{ArrayLike}</code>:
  the list of Elements to remove (must have a common parent)

- __returns__ <code>{void}</code>:
  
  
  Remove all Nodes in `oldElements` from the DOM.
  
   

### <code>nodeLists.replace(oldElements, newFrag)</code>


1. __oldElements__ <code>{ArrayLike}</code>:
  the list elements to remove
1. __newFrag__ <code>{DocumentFragment}</code>:
  the fragment to replace the old elements

- __returns__ <code>{void}</code>:
  
  
  Replaces `oldElements` with `newFrag`.
  
   
